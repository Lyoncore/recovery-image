#! /bin/sh -e
# initramfs local-premount script for repartition

# redirect output to serial console, since the HDMI output not enabled
# FIXME, the output console should be selectable
exec </dev/ttyS0 >/dev/ttyS0 2>&1
console="/dev/ttyS0"

PREREQ=""

# Output pre-requisites
prereqs()
{
    echo "$PREREQ"
}

debugshell()
{
    PS1='debugshell> ' /bin/sh -i <$console >$console 2>&1 # XXX: debug
}

case "$1" in
    prereqs)
        prereqs
        exit 0
        ;;
esac

set -x

# Check the recovery type
recoverytype=
for t in $(cat /proc/cmdline); do
    if [ "$t" = "recoverytype=factory_restore" ]; then
        recoverytype=factory_restore
        break
    elif [ "$t" = "recoverytype=factory_install" ]; then
        recoverytype=factory_install
        break
    elif [ "$t" = "recoverytype=headless_installer" ]; then
        recoverytype=headless_installer
        break
    elif [ "$t" = "recoverytype=custom" ]; then
        recoverytype=custom
        break
    elif [ "$t" = "fixrtc" ];then
        FIXRTC=ture
    fi
done

[ -n "$recoverytype" ] || exit 0 # nothing to do in non-recovery mode

#get recovery_label
recoverylabel=$(tr " " "\n" </proc/cmdline | grep "recovery=LABEL=" | sed -e 's/recovery=LABEL=\(.*\)/\1/')

wait-for-root "LABEL=$recoverylabel" "${ROOTDELAY:-180}" >/dev/null || true
recovery_part="$(findfs LABEL="$recoverylabel")"
[ -n "$recovery_part" ] || exit 1 # recovery partition not found


echo "[mount the recovery partition]"
BASE=/run/initramfs/recovery
mkdir -p $BASE
mkdir -p $BASE/recovery
mount -o defaults,ro "$recovery_part" $BASE/recovery

# TODO: Add prehook before recovery.bin

# fixrtc
# set to last modify time, the partition create time will be not be very old time
if [ -n $FIXRTC ]; then
    date "+%Y-%m-%d %T" --set="$(stat -c %y $BASE/recovery/recovery/factory/writable.tar.xz )"
fi

# mount core snap on chroot
core_snap=$(tr " " "\n" < /proc/cmdline | grep 'snap_core=' | sed -e 's/snap_core=//')
modprobe squashfs
osrootfs=$BASE/ossnap/
mkdir -p $osrootfs
mount $BASE/recovery/backup_snaps/$core_snap $osrootfs

newroot=$BASE/chroot/
mkdir -p $newroot
for dir in /bin /lib /lib64 /etc /var/ /usr /sbin; do
    if [ -d $osrootfs/$dir/ ]; then
    	mkdir -p $BASE/chroot/$dir/
    	mount --bind  $osrootfs/$dir/ $newroot/$dir/
    fi
done
for dir in /run /dev /tmp /sys /srv /proc /mnt /root /recovery /backup_snaps; do
    mkdir -p $newroot/$dir/
done

kernel_snap=$(tr " " "\n" < /proc/cmdline | grep 'snap_kernel=' | sed -e 's/snap_kernel=//')
kernelfs=$BASE/kerelsnap/
mkdir -p $kernelfs
mount $BASE/recovery/backup_snaps/$kernel_snap $kernelfs
# mount lib/modules/, lib/firmware/
for d in modules firmware; do
    # old deprecated
    if [ -d "$kernelfs/lib/$d" ]; then
        mount --bind $kernelfs/lib/$d $newroot/lib/$d
    fi
    # new style
    if [ -d "$kernelfs/$d" ]; then
        mount --bind $kernelfs/$d $newroot/lib/$d
    fi
done

mount --bind $BASE/recovery/recovery/ $newroot/recovery/
mount --bind $BASE/recovery/backup_snaps $newroot/backup_snaps/

echo "[switch_root to newroot]"
mount --bind /sys /$newroot/sys
mount --bind /proc /$newroot/proc
mount --bind /dev /$newroot/dev
mount --bind /run /$newroot/run
mount --bind $BASE/recovery /$newroot/$BASE/recovery

echo "[chroot execute recovery.bin]"

set +e
/bin/chroot /$newroot /recovery/bin/recovery.bin $recoverytype "$recoverylabel"
ret=$?

# ERESTART is errno 85 which restart system requirest from recovery.bin
if [ $ret == 85 ]; then
    reboot
elif [ $ret != 0 ]; then
    debugshell
elif [ $ret == 0 ] && [ "headless_installer" == $recoverytype ]; then
    poweroff
fi

# TODO: Add post hook after recovery.bin

sync

udevadm trigger
